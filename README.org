#+TITLE: Samples Assembly
#+DATE: <2025-04-11 Fri>

Code based on the lessons from the book [[https://a.co/d/hE556TU][Beginning x64 Assembly Programming]]. The
assembly used here is named [[https://en.wikipedia.org/wiki/Netwide_Assembler][NASM]] that stands for Netwide Assembler. Also, to
complement some gaps from the book explanation, I decided to use ChatGPT.

** .data section

In NASM for x86 assembly, the directives like ~db~, ~dw~, ~dd~, ~dq~, etc., are
used to define data in memory. These *are not data types in the high-level
language sense* , but rather instructions to the assembler about how many bytes
to allocate and optionally what initial values to store there.

| Directive | Stands for        | Bytes allocated                       |
|-----------+-------------------+---------------------------------------|
| db        | Define byte       | 1 byte                                |
| dw        | Define word       | 2 bytes                               |
| dd        | Define Doubleword | 4 bytes                               |
| dq        | Define Quadword   | 8 bytes                               |
| dt        | Define Ten bytes  | 10 bytes (used for FPU 80-bit floats) |

Example:

#+BEGIN_SRC nasm
  section .data
          my_byte      db 0x41           ; 1 byte initialized to 0x41
          my_string    db 'Hello', 0     ; A null-terminated string
          my_word      dw 0x1234         ; 2 bytes initialized to 0x1234
          my_dword     dd 0x12345678     ; 4 bytes initialized to 0x12345678
          my_qword     dq 0x123456789ABCDEF0 ; 8 bytes
          my_tbyte     dt 0              ; 10 bytes initialized to 0
#+END_SRC

These directives are typically used in the ~.data~ or ~.bss~ sections of the
assembly program.

*** FPU 80-bit floats

We can find 80-bit floating-point numbers in old programs, where these numbers
have their own instructions, called FPU instructions. This functionality is a
legacy from the past and should not be used in new developments.

** .bss section

In NASM, the ~.bss~ section is used to declare **uninitialized data** - i.e.,
memory that will be reserved but not initialized in the binary file. There we
can find directives for reserving some memory space, for example:

| Directive | Stands for          | Reserves                |
|-----------+---------------------+-------------------------|
| resb      | Reserve bytes       | 1 byte each             |
| resw      | Reserve words       | 2 bytes each            |
| resd      | Reserve Doublewords | 4 bytes each            |
| resq      | Reserve Quadwords   | 8 bytes each            |
| rest      | Reserve Ten bytes   | 10 bytes each (for FPU) |

Example:

#+BEGIN_SRC nasm
  section .bss
          buffer resq 4      ; reserves space for 4 quadwords = 4 * 8 = 32 bytes
#+END_SRC

+ WARNING :: Notice that we can't use the ~resq~ directive in the .data section.

** The stack

The stack, which is a contiguous array of memory locations, can be used as
temporary storage to save values in registers and call them back later or, more
importantly, to transfer values to functions.

The stack segment starts in high memory, and when it grows, it grows in the
downward direction, like an icicle grows downward when it grows larger. Items
are places on the stack with the push instruction and removed from the stack
with the pop instruction.

** How we know which registers to use for function arguments?

We use System V AMD64 Calling Convention (for Linux/macOS), which is the
standard for passing arguments to functions in 64-bit Linux programs. Here's how
it works:

| Argument # | Register | Notes                            |
|------------+----------+----------------------------------|
| 1st        | ~rdi~    |                                  |
| 2nd        | ~rsi~    |                                  |
| 3rd        | ~rdx~    |                                  |
| 4th        | ~rcx~    |                                  |
| 5th        | ~r8~     |                                  |
| 6th        | ~r9~     |                                  |
| 7th+       | Stack    | Pushed right-to-left (like in C) |

The return value (if any) is stored in ~rax~ register.

*** Special case: variadic functions (like ~printf~)

+ Variadic functions :: Functions that accept a variable number of arguments,
  not a fixed number. For example: (C) ~printf(const char *format, ...)~

You must set ~rax~ to 0 before calling a variadic function like ~printf~ with no
floating-point arguments.

Otherwise, we set its value according to how many floating-point arguments are
in ~xmm~ registers.
